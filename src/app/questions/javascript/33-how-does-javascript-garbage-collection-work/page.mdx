import GithubEdit from '@/components/github-edit';

export const metadata = {
  title: 'How does JavaScript garbage collection work?',
  publishDate: '2024-12-13T19:00:00Z',
  alternates: {
    canonical:
      '/questions/javascript/33-how-does-javascript-garbage-collection-work',
  },
};

# How does JavaScript garbage collection work?

The global JavaScript scope is the top-level namespace accessible to all scripts on a webpage. Modifying it might seem convenient, but it introduces significant risks and potential issues. Here's why it's a good idea to leave the global scope as-is:

---

## **Reasons to Avoid Modifying the Global Scope**

### 1. **Risk of Naming Collisions**

Adding variables, functions, or objects to the global scope can lead to naming conflicts with:

- Existing global variables or functions.
- Third-party libraries or frameworks.
- Future browser updates.

```javascript
// Adding a variable to the global scope
var myLibrary = {};

// A third-party library or another script might also declare 'myLibrary', causing overwrites.
```

### 2. **Harder to Debug and Maintain**

Global variables make it difficult to track where they are being used or modified, leading to unpredictable bugs.

```javascript
var counter = 0;

function increment() {
  counter++;
}

// Somewhere else in the code
counter = 10; // Unexpected behavior for increment()
```

### 3. **Encourages Poor Coding Practices**

Relying on the global scope often results in tightly coupled code, which is harder to refactor and reuse.

### 4. **Pollution of the Global Namespace**

Every addition to the global scope increases the chance of unintended interactions between scripts.

```javascript
// Script 1
var user = 'Alice';

// Script 2
var user = 'Bob'; // Overwrites the global variable declared by Script 1
```

### 5. **Potential Security Vulnerabilities**

Exposing sensitive data or methods in the global scope can make them accessible to malicious scripts.

```javascript
// Global variable with sensitive data
var apiKey = '12345';
// Malicious script can access 'apiKey'
```

---

## **Best Practices**

### 1. **Use Local Scope**

Declare variables and functions within local or block scopes to limit their visibility.

```javascript
function example() {
  let localVariable = 'This is local';
}

console.log(localVariable); // ReferenceError: localVariable is not defined
```

### 2. **Use IIFE (Immediately Invoked Function Expressions)**

Wrap code in an IIFE to create a private scope.

```javascript
(function () {
  var privateVar = 'I am private';
  console.log(privateVar); // Works
})();

console.log(privateVar); // ReferenceError: privateVar is not defined
```

### 3. **Use Modules**

Modern JavaScript supports modules (`import` and `export`), which encapsulate code and prevent global scope pollution.

```javascript
// file1.js
export const myFunction = () => console.log('Hello');

// file2.js
import { myFunction } from './file1.js';
myFunction();
```

### 4. **Namespace Your Code**

If adding global variables is unavoidable, use a single object as a namespace to contain all properties and methods.

```javascript
var MyApp = {
  utils: {},
  config: {},
};

MyApp.config.apiKey = '12345';
```

---

## **Conclusion**

Modifying the global scope in JavaScript is risky and can lead to unpredictable behavior, conflicts, and maintainability challenges. Instead, adopt best practices like using local scope, IIFEs, modules, or namespaces to write clean and robust code.

---

# How Does JavaScript Garbage Collection Work?

JavaScript's garbage collection is an automatic process that manages memory by removing objects that are no longer reachable or needed in the application.

---

## **Key Concepts**

### 1. **Memory Allocation**

When you create objects, variables, or functions, memory is allocated to store these values.

```javascript
let obj = { key: 'value' }; // Memory is allocated for 'obj'
```

### 2. **Reachability**

An object is considered "reachable" if it is:

- Referenced by a root (e.g., `window`, `global`).
- Accessible via references from other reachable objects.

### 3. **Garbage Collection Process**

The garbage collector identifies and removes objects that are no longer reachable. The primary algorithm used is:

#### **Mark-and-Sweep Algorithm**

1. Start with root objects (e.g., global variables, the call stack).
2. Mark all reachable objects.
3. Sweep and reclaim memory for unmarked (unreachable) objects.

```javascript
let obj = { key: 'value' };
obj = null; // The object is now unreachable and will be collected.
```

---

## **Common Triggers for Garbage Collection**

1. **Setting Variables to `null` or `undefined`:** Explicitly removing references.
   ```javascript
   let data = { key: 'value' };
   data = null; // Helps garbage collector reclaim memory.
   ```
2. **Out-of-Scope Variables:** Variables in local functions are collected when the function exits.
   ```javascript
   function example() {
     let temp = 'data';
   } // 'temp' is no longer reachable after the function ends.
   ```

---

## **Best Practices to Help Garbage Collection**

1. **Avoid Memory Leaks:**

   - Unintended references can prevent garbage collection.
   - Example: Adding listeners without removing them.

   ```javascript
   let element = document.getElementById('button');
   element.addEventListener('click', () => {
     console.log('Clicked!');
   });

   // If 'element' is not set to null, it may stay in memory.
   element = null; // Explicitly remove reference.
   ```

2. **Use WeakMaps and WeakSets:**
   These structures allow objects to be garbage-collected if no other references exist.

   ```javascript
   let weakMap = new WeakMap();
   let obj = {};
   weakMap.set(obj, 'value');
   obj = null; // Object can be garbage-collected.
   ```

---

## **Conclusion**

JavaScript's garbage collection ensures efficient memory management by reclaiming unused objects. While it works automatically, following best practices like managing references and avoiding memory leaks can improve performance and reliability.

---

## **References**

- [MDN Web Docs: Memory Management](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management)
- [Understanding Garbage Collection in JavaScript](https://blog.sessionstack.com/how-does-javascript-actually-work-part-2-memory-management-legacy-and-modern-optimization-6395ed4e5c5a)

<GithubEdit link='/questions/javascript/33-how-does-javascript-garbage-collection-work/page.mdx' />
